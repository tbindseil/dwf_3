TODO
1. make a linter
1a. camel case instead of snake case
2. whats the best way to deal with importing my own code? backend/index.ts line 2
3. vim buffers move to back
4. move method and entity constants to their own file (backend handlers dir)



orm and db management:
* maybe could translate ts models to python models, then just use sql alchemy
** this leaves the actual ORM to custom typescript stuff
** this also adds the translation of ts modules to python modules up to me also
*** this might be the deal breaker but is worth investigation
** could this be done by reading alembic from the database?


random text from index.ts
// now i have to connect to a database - TJTAG
// this will involve:
// 1. autogenerating database stuff based on models
// 2. connecting securely
//
// well, there are no good ORMs for typescript
//
// so what do i want it to do?
// given models (models/picture.ts for example):
// 1. I should be able to get the database looking right
// 1a. maybe just show differences?
// 2. I should be able to save and access objects, maybe autogenerate some basic queries
// 2a. nothing fancy, just get once and update on command
//
// connecting is a whole separate thing, that I probably should do first




        // temporary, test out db connection
        /*const query = 'SELECTy * from test_auto_increment where id = $1';
        const params = ['2'];
        db.query(query, params, (err: any, result: any) => {
            console.log(`err is ${err}`);
            console.log(`result is ${JSON.stringify(result)}`);

            // if (err) { throw new Error('error getting pictures'); }
        });*/

            /*
GET request received at /pictures
GetPictures.get_input
query is: function query(text, params, callback) {
    console.log("query is: ".concat(query));
    console.log("params are: ".concat(params));
    return pool.query(text, params, callback);
}
params are: 1
GetPictures.process
err is undefined
result is {"command":"SELECT","rowCount":1,"oid":null,"rows":[{"id":1,"name":"test_name"}],"fields":[{"name":"id","tableID":24588,"columnID":1,"dataTypeID":23,"dataTypeSize":4,"dataTypeModifier":-1,"format":"text"},{"name":"name","tableID":24588,"columnID":2,"dataTypeID":1043,"dataTypeSize":-1,"dataTypeModifier":-1,"format":"text"}],"_parsers":[null,null],"_types":{"_types":{"arrayParser":{},"builtins":{"BOOL":16,"BYTEA":17,"CHAR":18,"INT8":20,"INT2":21,"INT4":23,"REGPROC":24,"TEXT":25,"OID":26,"TID":27,"XID":28,"CID":29,"JSON":114,"XML":142,"PG_NODE_TREE":194,"SMGR":210,"PATH":602,"POLYGON":604,"CIDR":650,"FLOAT4":700,"FLOAT8":701,"ABSTIME":702,"RELTIME":703,"TINTERVAL":704,"CIRCLE":718,"MACADDR8":774,"MONEY":790,"MACADDR":829,"INET":869,"ACLITEM":1033,"BPCHAR":1042,"VARCHAR":1043,"DATE":1082,"TIME":1083,"TIMESTAMP":1114,"TIMESTAMPTZ":1184,"INTERVAL":1186,"TIMETZ":1266,"BIT":1560,"VARBIT":1562,"NUMERIC":1700,"REFCURSOR":1790,"REGPROCEDURE":2202,"REGOPER":2203,"REGOPERATOR":2204,"REGCLASS":2205,"REGTYPE":2206,"UUID":2950,"TXID_SNAPSHOT":2970,"PG_LSN":3220,"PG_NDISTINCT":3361,"PG_DEPENDENCIES":3402,"TSVECTOR":3614,"TSQUERY":3615,"GTSVECTOR":3642,"REGCONFIG":3734,"REGDICTIONARY":3769,"JSONB":3802,"REGNAMESPACE":4089,"REGROLE":4096}},"text":{},"binary":{}},"RowCtor":null,"rowAsArray":false}
        */




    //
    // I guess I can start with a server that can: - DONE
    // 1. receive updates and apply them to a master thing
    // 2. propagate updates
    // 3. register and unregister clients from photos
    // 4. send png of picture upon registration
    // 5. list pictures
    // 6. create pictures

    //
    // hmm, there is a crud app here and a registration service
    // i say this because the methods and routes are hard to name
    // no need to overthink it
    //



    // I think I could decode/inflate/etc a png file in a similar way to getting an image from below
    /*{
        fetch( 'https://upload.wikimedia.org/wikipedia/commons/4/47/PNG_transparency_demonstration_1.png' )
            .then( (r: Response) => r.arrayBuffer() )
            .then( buffer => { // note this is already an ArrayBuffer
                               // there is no buffer.data here
                    const blob = new Blob( [ buffer ] );
                    const url = URL.createObjectURL( blob );
                    const img = document.getElementById( 'img' );
                    console.log('buffer is:');
                    console.log(buffer);
                    console.log('url is:');
                    console.log(url);
                    console.log('img is:');
                    console.log(img);
                    // img.src = url; I commented this out
                    // So the Blob can be Garbage Collected
                    // img.onload = e => URL.revokeObjectURL( url );
                    // ... do something else with 'buffer'
                    } );
    }*/

    //
    //
    // why even bother with pngs at this point,
    // just request to join a picture
    // then, server gives image at a point in time
    // and starts sending updates for anything after that
    //
    // it (drawing with canvas' draw functionality as events occur) (https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/ellipse)
    // kind of leaves the question of how to shove something in that
    // was stuck in transit and is late. Ie how to draw something when
    // a later event has already been drawn?
    // Maybe just redraw from that event on? pretty mellow
    //
    // so I guess I'm drawing rectangles since that is easy

